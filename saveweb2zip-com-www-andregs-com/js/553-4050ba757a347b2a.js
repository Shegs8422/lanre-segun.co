"use strict"; (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([[553], {
  5379: (e, t, n) => { n.d(t, { D: () => s, N: () => u }); var r = n(12115), o = ["light", "dark"], i = "(prefers-color-scheme: dark)", l = r.createContext(void 0), a = { setTheme: e => { }, themes: [] }, s = () => { var e; return null != (e = r.useContext(l)) ? e : a }, u = e => r.useContext(l) ? e.children : r.createElement(d, { ...e }), c = ["light", "dark"], d = e => { let { forcedTheme: t, disableTransitionOnChange: n = !1, enableSystem: a = !0, enableColorScheme: s = !0, storageKey: u = "theme", themes: d = c, defaultTheme: v = a ? "system" : "light", attribute: y = "data-theme", value: g, children: b, nonce: E } = e, [x, w] = r.useState(() => m(u, v)), [C, T] = r.useState(() => m(u)), L = g ? Object.values(g) : d, N = r.useCallback(e => { let t = e; if (!t) return; "system" === e && a && (t = h()); let r = g ? g[t] : t, i = n ? p() : null, l = document.documentElement; if ("class" === y ? (l.classList.remove(...L), r && l.classList.add(r)) : r ? l.setAttribute(y, r) : l.removeAttribute(y), s) { let e = o.includes(v) ? v : null, n = o.includes(t) ? t : e; l.style.colorScheme = n } null == i || i() }, []), R = r.useCallback(e => { let t = "function" == typeof e ? e(e) : e; w(t); try { localStorage.setItem(u, t) } catch (e) { } }, [t]), S = r.useCallback(e => { T(h(e)), "system" === x && a && !t && N("system") }, [x, t]); r.useEffect(() => { let e = window.matchMedia(i); return e.addListener(S), S(e), () => e.removeListener(S) }, [S]), r.useEffect(() => { let e = e => { e.key === u && R(e.newValue || v) }; return window.addEventListener("storage", e), () => window.removeEventListener("storage", e) }, [R]), r.useEffect(() => { N(null != t ? t : x) }, [t, x]); let O = r.useMemo(() => ({ theme: x, setTheme: R, forcedTheme: t, resolvedTheme: "system" === x ? C : x, themes: a ? [...d, "system"] : d, systemTheme: a ? C : void 0 }), [x, R, t, C, a, d]); return r.createElement(l.Provider, { value: O }, r.createElement(f, { forcedTheme: t, disableTransitionOnChange: n, enableSystem: a, enableColorScheme: s, storageKey: u, themes: d, defaultTheme: v, attribute: y, value: g, children: b, attrs: L, nonce: E }), b) }, f = r.memo(e => { let { forcedTheme: t, storageKey: n, attribute: l, enableSystem: a, enableColorScheme: s, defaultTheme: u, value: c, attrs: d, nonce: f } = e, m = "system" === u, p = "class" === l ? "var d=document.documentElement,c=d.classList;".concat("c.remove(".concat(d.map(e => "'".concat(e, "'")).join(","), ")"), ";") : "var d=document.documentElement,n='".concat(l, "',s='setAttribute';"), h = s ? (o.includes(u) ? u : null) ? "if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'".concat(u, "'") : "if(e==='light'||e==='dark')d.style.colorScheme=e" : "", v = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2], r = c ? c[e] : e, i = t ? e + "|| ''" : "'".concat(r, "'"), a = ""; return s && n && !t && o.includes(e) && (a += "d.style.colorScheme = '".concat(e, "';")), "class" === l ? t || r ? a += "c.add(".concat(i, ")") : a += "null" : r && (a += "d[s](n,".concat(i, ")")), a }, y = t ? "!function(){".concat(p).concat(v(t), "}()") : a ? "!function(){try{".concat(p, "var e=localStorage.getItem('").concat(n, "');if('system'===e||(!e&&").concat(m, ")){var t='").concat(i, "',m=window.matchMedia(t);if(m.media!==t||m.matches){").concat(v("dark"), "}else{").concat(v("light"), "}}else if(e){").concat(c ? "var x=".concat(JSON.stringify(c), ";") : "").concat(v(c ? "x[e]" : "e", !0), "}").concat(m ? "" : "else{" + v(u, !1, !1) + "}").concat(h, "}catch(e){}}()") : "!function(){try{".concat(p, "var e=localStorage.getItem('").concat(n, "');if(e){").concat(c ? "var x=".concat(JSON.stringify(c), ";") : "").concat(v(c ? "x[e]" : "e", !0), "}else{").concat(v(u, !1, !1), ";}").concat(h, "}catch(t){}}();"); return r.createElement("script", { nonce: f, dangerouslySetInnerHTML: { __html: y } }) }), m = (e, t) => { let n; try { n = localStorage.getItem(e) || void 0 } catch (e) { } return n || t }, p = () => { let e = document.createElement("style"); return e.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(e), () => { window.getComputedStyle(document.body), setTimeout(() => { document.head.removeChild(e) }, 1) } }, h = e => (e || (e = window.matchMedia(i)), e.matches ? "dark" : "light") }, 68946: (e, t, n) => { n.d(t, { B: () => s }); var r, o = n(12115), i = n(4129), l = (r || (r = n.t(o, 2)))["useId".toString()] || (() => void 0), a = 0; function s(e) { let [t, n] = o.useState(l()); return (0, i.N)(() => { e || n(e => e ?? String(a++)) }, [e]), e || (t ? `radix-${t}` : "") } }, 71408: (e, t, n) => {
    n.d(t, { N: () => y }); var r = n(95155), o = n(12115), i = n(59686), l = n(94416), a = n(53127); class s extends o.Component { getSnapshotBeforeUpdate(e) { let t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { let e = this.props.sizeRef.current; e.height = t.offsetHeight || 0, e.width = t.offsetWidth || 0, e.top = t.offsetTop, e.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } } function u({ children: e, isPresent: t }) {
      let n = (0, o.useId)(), i = (0, o.useRef)(null), l = (0, o.useRef)({ width: 0, height: 0, top: 0, left: 0 }), { nonce: u } = (0, o.useContext)(a.Q); return (0, o.useInsertionEffect)(() => {
        let { width: e, height: r, top: o, left: a } = l.current; if (t || !i.current || !e || !r) return; i.current.dataset.motionPopId = n; let s = document.createElement("style"); return u && (s.nonce = u), document.head.appendChild(s), s.sheet && s.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${e}px !important;
            height: ${r}px !important;
            top: ${o}px !important;
            left: ${a}px !important;
          }
        `), () => { document.head.removeChild(s) }
      }, [t]), (0, r.jsx)(s, { isPresent: t, childRef: i, sizeRef: l, children: o.cloneElement(e, { ref: i }) })
    } let c = ({ children: e, initial: t, isPresent: n, onExitComplete: a, custom: s, presenceAffectsLayout: c, mode: f }) => { let m = (0, l.M)(d), p = (0, o.useId)(), h = (0, o.useMemo)(() => ({ id: p, initial: t, isPresent: n, custom: s, onExitComplete: e => { for (let t of (m.set(e, !0), m.values())) if (!t) return; a && a() }, register: e => (m.set(e, !1), () => m.delete(e)) }), c ? [Math.random()] : [n]); return (0, o.useMemo)(() => { m.forEach((e, t) => m.set(t, !1)) }, [n]), o.useEffect(() => { n || m.size || !a || a() }, [n]), "popLayout" === f && (e = (0, r.jsx)(u, { isPresent: n, children: e })), (0, r.jsx)(i.t.Provider, { value: h, children: e }) }; function d() { return new Map } var f = n(60296), m = n(45791); let p = e => e.key || ""; function h(e) { let t = []; return o.Children.forEach(e, e => { (0, o.isValidElement)(e) && t.push(e) }), t } var v = n(86553); let y = ({ children: e, exitBeforeEnter: t, custom: n, initial: i = !0, onExitComplete: a, presenceAffectsLayout: s = !0, mode: u = "sync" }) => { (0, m.V)(!t, "Replace exitBeforeEnter with mode='wait'"); let d = (0, o.useMemo)(() => h(e), [e]), y = d.map(p), g = (0, o.useRef)(!0), b = (0, o.useRef)(d), E = (0, l.M)(() => new Map), [x, w] = (0, o.useState)(d), [C, T] = (0, o.useState)(d); (0, v.E)(() => { g.current = !1, b.current = d; for (let e = 0; e < C.length; e++) { let t = p(C[e]); y.includes(t) ? E.delete(t) : !0 !== E.get(t) && E.set(t, !1) } }, [C, y.length, y.join("-")]); let L = []; if (d !== x) { let e = [...d]; for (let t = 0; t < C.length; t++) { let n = C[t], r = p(n); y.includes(r) || (e.splice(t, 0, n), L.push(n)) } "wait" === u && L.length && (e = L), T(h(e)), w(d); return } let { forceRender: N } = (0, o.useContext)(f.L); return (0, r.jsx)(r.Fragment, { children: C.map(e => { let t = p(e), o = d === C || y.includes(t); return (0, r.jsx)(c, { isPresent: o, initial: (!g.current || !!i) && void 0, custom: o ? void 0 : n, presenceAffectsLayout: s, mode: u, onExitComplete: o ? void 0 : () => { if (!E.has(t)) return; E.set(t, !0); let e = !0; E.forEach(t => { t || (e = !1) }), e && (null == N || N(), T(b.current), a && a()) }, children: e }, t) }) }) }
  }, 84860: (e, t, n) => { n.d(t, { UC: () => et, Kq: () => Z, bL: () => G, l9: () => ee }); var r, o = n(12115), i = n(92556), l = n(94446), a = n(3468), s = n(47650), u = n(95155), c = o.forwardRef((e, t) => { let { children: n, ...r } = e, i = o.Children.toArray(n), l = i.find(m); if (l) { let e = l.props.children, n = i.map(t => t !== l ? t : o.Children.count(e) > 1 ? o.Children.only(null) : o.isValidElement(e) ? e.props.children : null); return (0, u.jsx)(d, { ...r, ref: t, children: o.isValidElement(e) ? o.cloneElement(e, void 0, n) : null }) } return (0, u.jsx)(d, { ...r, ref: t, children: n }) }); c.displayName = "Slot"; var d = o.forwardRef((e, t) => { let { children: n, ...r } = e; if (o.isValidElement(n)) { let e = function (e) { let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (n = (t = Object.getOwnPropertyDescriptor(e, "ref")?.get) && "isReactWarning" in t && t.isReactWarning) ? e.props.ref : e.props.ref || e.ref }(n); return o.cloneElement(n, { ...function (e, t) { let n = { ...t }; for (let r in t) { let o = e[r], i = t[r]; /^on[A-Z]/.test(r) ? o && i ? n[r] = (...e) => { i(...e), o(...e) } : o && (n[r] = o) : "style" === r ? n[r] = { ...o, ...i } : "className" === r && (n[r] = [o, i].filter(Boolean).join(" ")) } return { ...e, ...n } }(r, n.props), ref: t ? (0, l.t)(t, e) : e }) } return o.Children.count(n) > 1 ? o.Children.only(null) : null }); d.displayName = "SlotClone"; var f = ({ children: e }) => (0, u.jsx)(u.Fragment, { children: e }); function m(e) { return o.isValidElement(e) && e.type === f } var p = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce((e, t) => { let n = o.forwardRef((e, n) => { let { asChild: r, ...o } = e, i = r ? c : t; return "undefined" != typeof window && (window[Symbol.for("radix-ui")] = !0), (0, u.jsx)(i, { ...o, ref: n }) }); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }, {}), h = n(70222), v = n(59584), y = "dismissableLayer.update", g = o.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), b = o.forwardRef((e, t) => { var n, a; let { disableOutsidePointerEvents: s = !1, onEscapeKeyDown: c, onPointerDownOutside: d, onFocusOutside: f, onInteractOutside: m, onDismiss: b, ...w } = e, C = o.useContext(g), [T, L] = o.useState(null), N = null != (a = null == T ? void 0 : T.ownerDocument) ? a : null == (n = globalThis) ? void 0 : n.document, [, R] = o.useState({}), S = (0, l.s)(t, e => L(e)), O = Array.from(C.layers), [P] = [...C.layersWithOutsidePointerEventsDisabled].slice(-1), k = O.indexOf(P), j = T ? O.indexOf(T) : -1, M = C.layersWithOutsidePointerEventsDisabled.size > 0, D = j >= k, I = function (e) { var t; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null == (t = globalThis) ? void 0 : t.document, r = (0, h.c)(e), i = o.useRef(!1), l = o.useRef(() => { }); return o.useEffect(() => { let e = e => { if (e.target && !i.current) { let t = function () { x("dismissableLayer.pointerDownOutside", r, o, { discrete: !0 }) }, o = { originalEvent: e }; "touch" === e.pointerType ? (n.removeEventListener("click", l.current), l.current = t, n.addEventListener("click", l.current, { once: !0 })) : t() } else n.removeEventListener("click", l.current); i.current = !1 }, t = window.setTimeout(() => { n.addEventListener("pointerdown", e) }, 0); return () => { window.clearTimeout(t), n.removeEventListener("pointerdown", e), n.removeEventListener("click", l.current) } }, [n, r]), { onPointerDownCapture: () => i.current = !0 } }(e => { let t = e.target, n = [...C.branches].some(e => e.contains(t)); D && !n && (null == d || d(e), null == m || m(e), e.defaultPrevented || null == b || b()) }, N), A = function (e) { var t; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null == (t = globalThis) ? void 0 : t.document, r = (0, h.c)(e), i = o.useRef(!1); return o.useEffect(() => { let e = e => { e.target && !i.current && x("dismissableLayer.focusOutside", r, { originalEvent: e }, { discrete: !1 }) }; return n.addEventListener("focusin", e), () => n.removeEventListener("focusin", e) }, [n, r]), { onFocusCapture: () => i.current = !0, onBlurCapture: () => i.current = !1 } }(e => { let t = e.target; ![...C.branches].some(e => e.contains(t)) && (null == f || f(e), null == m || m(e), e.defaultPrevented || null == b || b()) }, N); return (0, v.U)(e => { j === C.layers.size - 1 && (null == c || c(e), !e.defaultPrevented && b && (e.preventDefault(), b())) }, N), o.useEffect(() => { if (T) return s && (0 === C.layersWithOutsidePointerEventsDisabled.size && (r = N.body.style.pointerEvents, N.body.style.pointerEvents = "none"), C.layersWithOutsidePointerEventsDisabled.add(T)), C.layers.add(T), E(), () => { s && 1 === C.layersWithOutsidePointerEventsDisabled.size && (N.body.style.pointerEvents = r) } }, [T, N, s, C]), o.useEffect(() => () => { T && (C.layers.delete(T), C.layersWithOutsidePointerEventsDisabled.delete(T), E()) }, [T, C]), o.useEffect(() => { let e = () => R({}); return document.addEventListener(y, e), () => document.removeEventListener(y, e) }, []), (0, u.jsx)(p.div, { ...w, ref: S, style: { pointerEvents: M ? D ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: (0, i.m)(e.onFocusCapture, A.onFocusCapture), onBlurCapture: (0, i.m)(e.onBlurCapture, A.onBlurCapture), onPointerDownCapture: (0, i.m)(e.onPointerDownCapture, I.onPointerDownCapture) }) }); function E() { let e = new CustomEvent(y); document.dispatchEvent(e) } function x(e, t, n, r) { let { discrete: o } = r, i = n.originalEvent.target, l = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); if (t && i.addEventListener(e, t, { once: !0 }), o) i && s.flushSync(() => i.dispatchEvent(l)); else i.dispatchEvent(l) } b.displayName = "DismissableLayer", o.forwardRef((e, t) => { let n = o.useContext(g), r = o.useRef(null), i = (0, l.s)(t, r); return o.useEffect(() => { let e = r.current; if (e) return n.branches.add(e), () => { n.branches.delete(e) } }, [n.branches]), (0, u.jsx)(p.div, { ...e, ref: i }) }).displayName = "DismissableLayerBranch"; var w = n(68946), C = n(68913), T = n(4129); o.forwardRef((e, t) => { var n, r; let { container: i, ...l } = e, [a, c] = o.useState(!1); (0, T.N)(() => c(!0), []); let d = i || a && (null == (r = globalThis) || null == (n = r.document) ? void 0 : n.body); return d ? s.createPortal((0, u.jsx)(p.div, { ...l, ref: t }), d) : null }).displayName = "Portal"; var L = e => { let { present: t, children: n } = e, r = function (e) { var t, n; let [r, i] = o.useState(), l = o.useRef({}), a = o.useRef(e), u = o.useRef("none"), [c, d] = (t = e ? "mounted" : "unmounted", n = { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }, o.useReducer((e, t) => { let r = n[e][t]; return null != r ? r : e }, t)); return o.useEffect(() => { let e = N(l.current); u.current = "mounted" === c ? e : "none" }, [c]), (0, T.N)(() => { let t = l.current, n = a.current; if (n !== e) { let r = u.current, o = N(t); e ? d("MOUNT") : "none" === o || (null == t ? void 0 : t.display) === "none" ? d("UNMOUNT") : n && r !== o ? d("ANIMATION_OUT") : d("UNMOUNT"), a.current = e } }, [e, d]), (0, T.N)(() => { if (r) { let e = e => { let t = N(l.current).includes(e.animationName); e.target === r && t && s.flushSync(() => d("ANIMATION_END")) }, t = e => { e.target === r && (u.current = N(l.current)) }; return r.addEventListener("animationstart", t), r.addEventListener("animationcancel", e), r.addEventListener("animationend", e), () => { r.removeEventListener("animationstart", t), r.removeEventListener("animationcancel", e), r.removeEventListener("animationend", e) } } d("ANIMATION_END") }, [r, d]), { isPresent: ["mounted", "unmountSuspended"].includes(c), ref: o.useCallback(e => { e && (l.current = getComputedStyle(e)), i(e) }, []) } }(t), i = "function" == typeof n ? n({ present: r.isPresent }) : o.Children.only(n), a = (0, l.s)(r.ref, function (e) { var t, n; let r = null == (t = Object.getOwnPropertyDescriptor(e.props, "ref")) ? void 0 : t.get, o = r && "isReactWarning" in r && r.isReactWarning; return o ? e.ref : (o = (r = null == (n = Object.getOwnPropertyDescriptor(e, "ref")) ? void 0 : n.get) && "isReactWarning" in r && r.isReactWarning) ? e.props.ref : e.props.ref || e.ref }(i)); return "function" == typeof n || r.isPresent ? o.cloneElement(i, { ref: a }) : null }; function N(e) { return (null == e ? void 0 : e.animationName) || "none" } L.displayName = "Presence"; var R = n(23558), S = o.forwardRef((e, t) => (0, u.jsx)(p.span, { ...e, ref: t, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...e.style } })); S.displayName = "VisuallyHidden"; var [O, P] = (0, a.A)("Tooltip", [C.Bk]), k = (0, C.Bk)(), j = "TooltipProvider", M = "tooltip.open", [D, I] = O(j), A = e => { let { __scopeTooltip: t, delayDuration: n = 700, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: l } = e, [a, s] = o.useState(!0), c = o.useRef(!1), d = o.useRef(0); return o.useEffect(() => { let e = d.current; return () => window.clearTimeout(e) }, []), (0, u.jsx)(D, { scope: t, isOpenDelayed: a, delayDuration: n, onOpen: o.useCallback(() => { window.clearTimeout(d.current), s(!1) }, []), onClose: o.useCallback(() => { window.clearTimeout(d.current), d.current = window.setTimeout(() => s(!0), r) }, [r]), isPointerInTransitRef: c, onPointerInTransitChange: o.useCallback(e => { c.current = e }, []), disableHoverableContent: i, children: l }) }; A.displayName = j; var _ = "Tooltip", [W, B] = O(_), U = e => { let { __scopeTooltip: t, children: n, open: r, defaultOpen: i = !1, onOpenChange: l, disableHoverableContent: a, delayDuration: s } = e, c = I(_, e.__scopeTooltip), d = k(t), [f, m] = o.useState(null), p = (0, w.B)(), h = o.useRef(0), v = null != a ? a : c.disableHoverableContent, y = null != s ? s : c.delayDuration, g = o.useRef(!1), [b = !1, E] = (0, R.i)({ prop: r, defaultProp: i, onChange: e => { e ? (c.onOpen(), document.dispatchEvent(new CustomEvent(M))) : c.onClose(), null == l || l(e) } }), x = o.useMemo(() => b ? g.current ? "delayed-open" : "instant-open" : "closed", [b]), T = o.useCallback(() => { window.clearTimeout(h.current), g.current = !1, E(!0) }, [E]), L = o.useCallback(() => { window.clearTimeout(h.current), E(!1) }, [E]), N = o.useCallback(() => { window.clearTimeout(h.current), h.current = window.setTimeout(() => { g.current = !0, E(!0) }, y) }, [y, E]); return o.useEffect(() => () => window.clearTimeout(h.current), []), (0, u.jsx)(C.bL, { ...d, children: (0, u.jsx)(W, { scope: t, contentId: p, open: b, stateAttribute: x, trigger: f, onTriggerChange: m, onTriggerEnter: o.useCallback(() => { c.isOpenDelayed ? N() : T() }, [c.isOpenDelayed, N, T]), onTriggerLeave: o.useCallback(() => { v ? L() : window.clearTimeout(h.current) }, [L, v]), onOpen: T, onClose: L, disableHoverableContent: v, children: n }) }) }; U.displayName = _; var z = "TooltipTrigger", F = o.forwardRef((e, t) => { let { __scopeTooltip: n, ...r } = e, a = B(z, n), s = I(z, n), c = k(n), d = o.useRef(null), f = (0, l.s)(t, d, a.onTriggerChange), m = o.useRef(!1), h = o.useRef(!1), v = o.useCallback(() => m.current = !1, []); return o.useEffect(() => () => document.removeEventListener("pointerup", v), [v]), (0, u.jsx)(C.Mz, { asChild: !0, ...c, children: (0, u.jsx)(p.button, { "aria-describedby": a.open ? a.contentId : void 0, "data-state": a.stateAttribute, ...r, ref: f, onPointerMove: (0, i.m)(e.onPointerMove, e => { "touch" !== e.pointerType && (h.current || s.isPointerInTransitRef.current || (a.onTriggerEnter(), h.current = !0)) }), onPointerLeave: (0, i.m)(e.onPointerLeave, () => { a.onTriggerLeave(), h.current = !1 }), onPointerDown: (0, i.m)(e.onPointerDown, () => { m.current = !0, document.addEventListener("pointerup", v, { once: !0 }) }), onFocus: (0, i.m)(e.onFocus, () => { m.current || a.onOpen() }), onBlur: (0, i.m)(e.onBlur, a.onClose), onClick: (0, i.m)(e.onClick, a.onClose) }) }) }); F.displayName = z; var [V, $] = O("TooltipPortal", { forceMount: void 0 }), H = "TooltipContent", K = o.forwardRef((e, t) => { let n = $(H, e.__scopeTooltip), { forceMount: r = n.forceMount, side: o = "top", ...i } = e, l = B(H, e.__scopeTooltip); return (0, u.jsx)(L, { present: r || l.open, children: l.disableHoverableContent ? (0, u.jsx)(q, { side: o, ...i, ref: t }) : (0, u.jsx)(J, { side: o, ...i, ref: t }) }) }), J = o.forwardRef((e, t) => { let n = B(H, e.__scopeTooltip), r = I(H, e.__scopeTooltip), i = o.useRef(null), a = (0, l.s)(t, i), [s, c] = o.useState(null), { trigger: d, onClose: f } = n, m = i.current, { onPointerInTransitChange: p } = r, h = o.useCallback(() => { c(null), p(!1) }, [p]), v = o.useCallback((e, t) => { let n = e.currentTarget, r = { x: e.clientX, y: e.clientY }, o = function (e, t) { let n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), i = Math.abs(t.left - e.x); switch (Math.min(n, r, o, i)) { case i: return "left"; case o: return "right"; case n: return "top"; case r: return "bottom"; default: throw Error("unreachable") } }(r, n.getBoundingClientRect()); c(function (e) { let t = e.slice(); return t.sort((e, t) => e.x < t.x ? -1 : e.x > t.x ? 1 : e.y < t.y ? -1 : 1 * !!(e.y > t.y)), function (e) { if (e.length <= 1) return e.slice(); let t = []; for (let n = 0; n < e.length; n++) { let r = e[n]; for (; t.length >= 2;) { let e = t[t.length - 1], n = t[t.length - 2]; if ((e.x - n.x) * (r.y - n.y) >= (e.y - n.y) * (r.x - n.x)) t.pop(); else break } t.push(r) } t.pop(); let n = []; for (let t = e.length - 1; t >= 0; t--) { let r = e[t]; for (; n.length >= 2;) { let e = n[n.length - 1], t = n[n.length - 2]; if ((e.x - t.x) * (r.y - t.y) >= (e.y - t.y) * (r.x - t.x)) n.pop(); else break } n.push(r) } return (n.pop(), 1 === t.length && 1 === n.length && t[0].x === n[0].x && t[0].y === n[0].y) ? t : t.concat(n) }(t) }([...function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5, r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }) }return r }(r, o), ...function (e) { let { top: t, right: n, bottom: r, left: o } = e; return [{ x: o, y: t }, { x: n, y: t }, { x: n, y: r }, { x: o, y: r }] }(t.getBoundingClientRect())])), p(!0) }, [p]); return o.useEffect(() => () => h(), [h]), o.useEffect(() => { if (d && m) { let e = e => v(e, m), t = e => v(e, d); return d.addEventListener("pointerleave", e), m.addEventListener("pointerleave", t), () => { d.removeEventListener("pointerleave", e), m.removeEventListener("pointerleave", t) } } }, [d, m, v, h]), o.useEffect(() => { if (s) { let e = e => { let t = e.target, n = { x: e.clientX, y: e.clientY }, r = (null == d ? void 0 : d.contains(t)) || (null == m ? void 0 : m.contains(t)), o = !function (e, t) { let { x: n, y: r } = e, o = !1; for (let e = 0, i = t.length - 1; e < t.length; i = e++) { let l = t[e].x, a = t[e].y, s = t[i].x, u = t[i].y; a > r != u > r && n < (s - l) * (r - a) / (u - a) + l && (o = !o) } return o }(n, s); r ? h() : o && (h(), f()) }; return document.addEventListener("pointermove", e), () => document.removeEventListener("pointermove", e) } }, [d, m, s, f, h]), (0, u.jsx)(q, { ...e, ref: a }) }), [X, Y] = O(_, { isInside: !1 }), q = o.forwardRef((e, t) => { let { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: l, onPointerDownOutside: a, ...s } = e, c = B(H, n), d = k(n), { onClose: m } = c; return o.useEffect(() => (document.addEventListener(M, m), () => document.removeEventListener(M, m)), [m]), o.useEffect(() => { if (c.trigger) { let e = e => { let t = e.target; (null == t ? void 0 : t.contains(c.trigger)) && m() }; return window.addEventListener("scroll", e, { capture: !0 }), () => window.removeEventListener("scroll", e, { capture: !0 }) } }, [c.trigger, m]), (0, u.jsx)(b, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: l, onPointerDownOutside: a, onFocusOutside: e => e.preventDefault(), onDismiss: m, children: (0, u.jsxs)(C.UC, { "data-state": c.stateAttribute, ...d, ...s, ref: t, style: { ...s.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [(0, u.jsx)(f, { children: r }), (0, u.jsx)(X, { scope: n, isInside: !0, children: (0, u.jsx)(S, { id: c.contentId, role: "tooltip", children: i || r }) })] }) }) }); K.displayName = H; var Q = "TooltipArrow"; o.forwardRef((e, t) => { let { __scopeTooltip: n, ...r } = e, o = k(n); return Y(Q, n).isInside ? null : (0, u.jsx)(C.i3, { ...o, ...r, ref: t }) }).displayName = Q; var Z = A, G = U, ee = F, et = K }
}]);